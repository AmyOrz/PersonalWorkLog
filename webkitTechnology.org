**  网页渲染过程
*** 1.从网页URL到构建完DOM树
    1.当用户输入网页URL时,webkit调用其资源加载器加载该URL对应的网页;
    2.加载器依赖网络模块建立连接,发送请求并接受回复;
    3.webkit接收到各种网页或者资源数据, 其中某些资源可能是同步或异步获取的;
    4.网页交给HTML解析器转变为词语；
    5.解释器根据词语构建节点，形成DOM树；
    6.如果节点是JavaScript代码，调用JavaScript引擎解释并执行；
    7.JavaScript代码可能会修改DOM树结构；
    8.如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。
    

*** 从DOM树到构建WebKit绘图上下
    1.CSS文件被CSS解释器解释成内部表示；
    2.CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；
    3.RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。
    

*** 绘图上下文到最终图像呈现
    1.绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；
    2.绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；
    3.绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。
    
** chrome 多进程模型
*** browser主进程
**** 负责浏览器界面的显示,各个页面的管理,是所有其他类型进程的祖先,负责他们的创建和销毁工作.只有一个
*** renderer 进程
**** 网页的渲染进程,负责页面的渲染工作,webkit渲染工作主要在这个进程完成,可有多个
***  NPAPI 插件进程
**** 创建的基本原则是每种类型的插件只会被创建一次,仅当使用时才创建,当多个网页使用同种类型的插件,进程可被共享
*** GPU进程
**** 只有一个,仅当GPU硬件加速打开时候才被创建,主要用于3D图形加速调用的实现
*** PPAPI 插件进程
**** 同NPAPI,不同的是为Pepper插件而创建的进程
** chrome 多线程模型
*** 每个进程内部都有多个线程,主要目的是为了保持用户界面的高度响应度,保证UI线程不会被任何其他费时操作阻碍影响对用户操作的响应.
** 资源缓存
**** 建立一个资源的缓存池,当webkit需要请求资源的时候,先从资源池中查找是否存在相应的资源.
**** 如果有则取出使用,没有的话webkit创建一个新的cachedResource子类对象,并发送真正的请求给服务器,webkit收到资源后将其设置到资源类对象中
**** Webkit从资源池中查找资源的关键字是URL,因为标记资源唯一性的特征就是资源的URL,如果2个资源有不同的URL,但他们内容相同,也被认为是2个不同资源
     
**  DOM树
*** 构建流程
**** 我们经过网络拿到html文件的字节流(bytes) ---> 字符流(Characters)  ---> 词法解析---> 节点 ----> DOM树

*** Js执行
**** 在html解析器工作中,可能会遇到Js代码(全局作用域)需要执行,他发生在将字符串解析成词语之后,创建各种节点的时候,这时Js不能访问DOM树,因为DOM树还没构建完成.

*** 事件的工作过程
**** 事件捕获:事件从document节点开始自顶向下开始查找,找到之后可以使用stopPropagation函数阻止事件向下传递
**** 事件冒泡:事件从目标开始自底向上开始冒泡,逐级触发事件,可以使用stopPropagation函数阻止事件向上冒泡
**** 可以使用preventDefault来阻止默认事件

** Css解析器:在Dom树构建后,RenderObject树构建之前
*** 解析过程:Css字符串经过css解释器处理编程渲染引擎的内部规则表达式.
**** 根据Css选择器匹配到对应的dom节点,然后存储该节点Css样式结果去构建RenderObject树

** webkit渲染:RenderObject树和其他树(如RenderLayer)构成webkit渲染的主要基础设施
*** RenderObject树:以下规则会为DOM树节点创建一个RenderObject对象
**** 1.DOM树的document节点
**** 2.DOM树中可视节点(html,body,div等),而不会为不可视节点(meta) 创建
**** 3.某些情况webkit 需要创建匿名RenderObject节点,该节点不对应于DOM树中的任何节点
**** 这些RenderObject节点会构成一棵RenderObject树


*** RenderLayer树:webKit为网页的层次创建相应的RenderLayer树
**** 某些类型的RenderObject节点或具有Css样式的RenderObject节点出现的时候Webkit就会为这些节点创建RenderLayer对象,一般来说,某个RenderObject节点的后代都属于该节点
**** 1.DOM树的Document节点对应的RenderView节点
**** 2.DOM树中Document的子女节点,就是HTML节点对应的RenderBlock节点
**** 3.显式的指定Css位置的RenderObject节点
**** 4.有透明效果的RenderObject节点
**** 5.节点有溢出(overflow),alpha,反射效果的RenderObject节点
**** 6.使用canvas2D / 3D 技术的RenderObject节点
**** 7.Video节点对应的RenderObject节点
**** 这些RenderLayer节点会构成一棵RenderLayer树
     
** V8引擎   
*** js与静态语言区别:
**** 1.编译确定位置:
***** 静态语言: 有明确的两个阶段,编译这些位置的偏移信息都是编译器在编译的时候就决定了,当C++被编译成本地代码之后,对象的属性和偏移信息都计算完成了
***** Js: 没有类型,只有在对象创建的时候才知道位置信息,所以只能在执行阶段确定,而且Js能够在执行时修改对象的属性
**** 2.偏移信息共享:
***** 静态语言: c++因为有类型,所有对象都是按照该类型来确定,而且不能在执行时动态修改类型,因为这些都是共享偏移信息的,访问只需偏移量就可以
***** js:每个对象都是自描述,属性和位置偏移信息都包含在自身的结构中
**** 3.偏移信息查找:
***** 静态语言:c++中查找偏移地址很简单,都是在编译代码时,对使用到某类型的成员变量直接设置偏移量
***** js:使用到一个对象则需要通过属性名匹配才能查找到对应的值,实在浪费时间
**** 总结:因为对象属性的访问非常普遍而且次数频繁,而通过偏移量来访问值并且知道该值的类型,可以减少很多倍的时间消耗,并且属性名匹配需要很长时间,还消耗内存
*** JIT
**** 在代码的世界中，通常有两种方式来翻译机器语言：解释器和编译器。
**** 解释器:翻译是一行行地边解释边执行。
*****  解释器的利弊
****** 解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。
******  正是因为这个原因，解释器看起来更加适合 JavaScript。对于一个 Web 开发人员来讲，能够快速执行代码并看到结果是非常重要的。
****** 可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。
**** 编译器:是把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。
***** 编译器的利弊
****** 编译器的问题则恰好相反。它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。
****** 另外一个不同是，编译器可以用更多的时间对代码进行优化，以使代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。
**** 如何提升JavaScript运行性能呢
***** Just-in-time 编译器：综合了两者的优点。为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成混合模式。大致原理如下：
***** 监视器：增加监视器监控着代码的运行情况，记录代码一共运行了多少次，如何运行的等信息。
***** 监视器监视着所有通过解释器的代码。如果同一行代码运行了几次，这个代码段就被标记成了 “warm”，如果运行了很多次，则被标记成 “hot”。
***** 基线编译器：如果一段代码变成了 “warm”，那么 JIT 就把它送到编译器去编译，并且把编译结果存储起来。
***** 优化编译器：如果一个代码段变得 “very hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储之。
***** 为了使执行速度变快，JIT 会增加很多多余的开销，这些开销包括：
****** 优化和去优化开销；
****** 监视器记录信息对内存的开销；
****** 发生去优化情况时恢复信息的记录对内存的开销；
****** 对基线版本和优化后版本记录的内存开销。 这里还有很大的提升空间：即消除开销。通过消除开销使得性能上有进一步地提升，这也是WebAssembly所要做的事之一。
*** setTimeout,setInterval 不足
**** 他们不考虑浏览器内部发生了什么，只要求浏览器在指定时间后调用回调函数，无论浏览器多繁忙或者页面被隐藏
**** 只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以他们实际执行时间比设定时间晚一些
**** 刷新频率受屏幕分辨率和屏幕尺寸影响，因此不同设备刷新频率不同，而他们设置固定刷新时间，很可能造成资源浪费
**** setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。
**** 如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。
***** 假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：
***** 第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；
***** 第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；
***** 第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；
***** 第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;
***** 第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;
***** 第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中；
*** requestAnimationFrame优势
**** 由系统来决定回调函数的执行时机
**** 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms
**** requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次
