* gl.clearColor(red, green, blue, alpha)
*** 一旦指定了背景色之后, 背景色就会驻村在webgl系统中,在下次调用gl.clearColor前不会改变
* gl.clear(buffer)
*** 将指定缓冲区设定为预定的值,如果buffer为颜色缓冲区, 那么将使用gl.clearColor指定的值
* 数据类型
*** float 浮点数
*** vec3/vec4  表示3/4个浮点数组成的矢量
*** 类型化数组:webgl处理大量相同类型的数据,为了性能优化
**** Float32Array 通常用来存储顶点坐标或颜色数据
**** Int8Array    8位整型数          Int16Array     Int32Array
**** Uint8Array   8位无符号整型数    Uint16Array    UInt32Array
**** Float32Array   Float64Array
*** mat4  4*4矩阵
*** gl.uniformMaterix4fv
**** location 
**** transpose   一般为false
**** array      类型化数组,4*4矩阵按列主序
* 着色器
*** 定点着色器: 控制点的位置和大小
**** vec4 gl_Position  定点位置
***** 必须被赋值, 不然片元着色器无法工作
**** float gl_PointSize 点的尺寸
***** 不是必须的,不赋值取默认值1.0
*** 片元着色器: 控制点的颜色
**** vec4 gl_FragColor  指定片元的颜色
***** 唯一内置变量, 控制着像素在屏幕上的最终颜色
* attribute 存储限定符
*** 从外部向定点着色器内传输数据, 只有定点着色器能使用
*** 在定点着色器中声名attribute变量
**** attribute vec4 a_Position;
*** 通过gl.getAttribLocation 获取变量
**** 参数
***** program  指定包含定点着色器和片元着色器的程序对象
***** name     指定想要获取的attribute变量名
*** 向attribute变量传输数据
**** 通过gl.vertexAttrib1f/gl.vertexAttrib2f/gl.vertexAttrib3f/gl.vertexAttrib4f同族函数向attribute赋值
**** 当我只赋值前3个参数时,第四个参数默认为1.0
**** var position = new Float32Array([1.0,2.0,3.0]);
**** gl.vertexAttrib3f(a_Position, position);

* uniform 存储限定符
*** 从程序向顶点着色器和片元着色器传输不变数据
*** 声名uniform变量
**** uniform vec4 a_FragColor;
*** 通过gl.getUniformLocation获取变量
**** 参数
***** progrBoxam  指定包含定点着色器和片元着色器的程序对象
***** name     指定想要获取的uniform变量名
*** 向uniform变量传输数据
**** gl.uniform1f/gl.uniform2f/gl.uniform3f/gl.uniform4f同族函数
**** 当我只赋值前3个参数时,第四个参数默认为1.0
* varying变量
*** 从顶点着色器向片元着色器传输数据
**** 我们设置每个顶点的color, 但vbo只能是顶点着色器使用
**** 我们可以通过varying来从顶点着色器取出值来传给片元着色器,这样我们就可以传输大量顶点color值

* 顶点缓冲对象(VBO)
*** 三角形,立方体需要一次性将顶点全部传入顶点着色器,然后才能把图形画出来.
*** 而且可以创建多个buffer来缓存多个geometry的顶点数据,当我们需要绘制时只需要取出buffer就可以绘制会图形
*** 定义:是Webgl系统中的一块内存区域, 可以一次性向缓冲区对象中填充大量顶点数据, 然后将这些数据保存在其中,供定点着色器使用
*** 步骤:
**** 创建缓冲区对象(gl.createBuffer)
**** 绑定缓冲区(gl.bindBuffer)
***** 参数:
***** target
****** gl.ARRAY_BUFFER           表示缓冲区对象中包含了顶点的数据
****** gl.ELEMENT_ARRAY_BUFFER   表示缓冲区对象中包含了顶点的索引值
***** buffer
**** 向缓冲区对象中写入数据(gl.bufferData)
***** 参数:
***** target: 
****** gl.ARRAY_BUFFER           表示缓冲区对象中包含了顶点的数据
****** gl.ELEMENT_ARRAY_BUFFER   表示缓冲区对象中包含了顶点的索引值
***** buffer
***** usage         程序如何使用存储在缓冲区对象中的数据
****** gl.STATIC_DRAW     只会向缓冲区对象中写入一次数据,需要绘制多次
****** gl.STREAM_DRAW     只会向缓冲区对象中写入一次数据,绘制若干次
****** gl.DYNAMIC_DRAW    向缓冲区对象写入多次数据,绘制多次
**** 将缓冲区对象分配给attribute变量(gl.vertexAttribPointer)
***** location      指定attribute变量存储位置
***** size          缓冲区每个顶点的分量个数(1-4)
***** type
****** gl.UNSIGNED_BYTE   无符号字节,UInt8Array
****** gl.SHORT           短整型,Int16Array
****** gl.UNSIGNED_SHORT  无符号短整型,UInt16Array
****** gl.INT             整型,Int32Array
****** gl.UNSIGNED_INT    无符号整型,UInt32Array
****** gl.FLOAT           浮点数,Float32Array
***** normalize    一般为false
***** stride       指定相邻2个顶点间的字节数,默认为0
***** offset       缓存区对象中的偏移量
**** 开启attribute变量(gl.enableVertexAttribArray)
* 绘制管线:给定视点,三维物体,光源,照明模式,纹理等元素,绘制一副二维图像
** 渲染管线:
*** 顶点着色器:
**** 执行顶点着色器,缓冲区对象第一个坐标(0.0,0.5)被传递给attribute变量a_position
**** 一旦一个顶点坐标被赋值给gl_Position,他就进入图形装配区域,暂时存储在那
**** 再次执行顶点着色器,将剩余的顶点依次存储到图形装配区,进行装配图形
*** 图元装配
**** 将顶点着色器输出的所有顶点作为输入,将所有点装配成指定的图元的形状(三角形,点)
**** 然后把装配的图形传给几何着色器
*** 几何着色器
**** 将一系列顶点集合作为输入,通过产生新的顶点构造出新的图元来生成其他形状(三角形)
*** 光栅化阶段
**** 把图元映射为最终屏幕上相应的像素,生成供片元着色器使用的片段
**** 在片元着色器执行前会执行裁剪,裁剪丢弃你超出你试图以外的像素
*** 片元着色器
**** 计算像素最终颜色
*** alpha测试和混合
**** 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。
**** 这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。
** 应用阶段:
*** 碰撞检测,场景图建立,空间八叉树更新,视锥裁剪都在此阶段
*** 该阶段末尾,几何数据(顶点坐标,法向量,纹理坐标,纹理等)通过数据总线传送到GPU
**** 这里由用户把顶点数据通过顶点缓冲对象传入到GPU,然后通过GPU渲染管线
** 几何阶段:
*** 主要负责顶点坐标变换,光照,裁剪,投影以及屏幕映射,该阶段基于GPU进行运算
*** 该阶段末尾得到了经过变换和投影之后的顶点坐标,颜色,以及纹理坐标
*** 这个阶段执行了坐标系转换
** 光栅化阶段
*** 基于几何阶段的输出数据,为像素正确配色,该阶段都是操作单个像素,每个像素的信息存储在颜色缓冲器中
** PS:
*** 光照计算属于几何阶段
**** 因为光照涉及到视点,光源和物体的世界坐标,通常在世界坐标系中进行计算
*** 雾化和涉及物体透明度计算属于光栅化阶段
**** 因为用到了深度信息z值,而z值是在几何阶段中计算,并传入到光栅阶段的,只能在光栅阶段获取到
*** 屏幕是二维的,GPU所需要做的就是将三维的数据绘制到二维屏幕上,顶点变换每个过程都是这个目的
* 坐标系统
** 局部空间
*** 模型文件中的顶点值,是在建模型时得到的
*** 与其他物体是没有任何参照关系的
*** PS:顶点法向量在模型中属于局部坐标,在GPU顶点着色器程序中必须将法向量转换到世界坐标系才能使用
** 世界坐标系
*** 指顶点相对于游戏世界的坐标.
*** 物体坐标从局部坐标转换到世界坐标,该转换由模型矩阵实现
*** Model Matrix: 通过对物体进行位移,缩放,旋转来将它置于他本应该在的位置和朝向
** 观察空间
*** 将世界坐标转化为用户视野前方的坐标而产生的结果
*** 就是摄像机的视角所观察到的空间
*** 观察矩阵(View Matrix)，它被用来将世界坐标变换到观察空间。
** 裁剪空间
*** 一旦顶点坐标被转换到观察空间,就需要判断哪些视点是可见的,会将投影矩阵以外的点去除,称为视锥裁剪
*** 裁剪被安排到一个单位立方体中进行,该立方体顶点分别是(-1,-1,-1)和(1,1,1),被称为规范立方体(CVV)
*** CVV的近平面(梯形较小的矩形面)的X,Y坐标对应屏幕像素坐标,z代表画面深度
*** 从视点坐标到裁剪坐标经过以下3步:
*** 1.用透视矩阵把顶点从视锥中变换到CVV中(投影)
*** 2.在CVV中进行图片裁剪
*** 3.屏幕映射
* 程序对象(program)
