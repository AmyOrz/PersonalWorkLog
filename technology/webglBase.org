* webgl学习路线
*** WebGL编程指南
*** 学习wonderJs引擎
*** 学习《实时渲染》
*** 游戏引擎架构

* gl.clearColor(red, green, blue, alpha)
*** 一旦指定了背景色之后, 背景色就会驻存在webgl系统中,在下次调用gl.clearColor前不会改变
* gl.clear(buffer)
*** 将指定缓冲区设定为预定的值,如果buffer为颜色缓冲区, 那么将使用gl.clearColor指定的值
* 数据类型
*** float 浮点数
*** vec3/vec4  表示3/4个浮点数组成的矢量
*** 类型化数组:webgl处理大量相同类型的数据,为了性能优化
**** Float32Array 通常用来存储顶点坐标或颜色数据
**** Int8Array    8位整型数          Int16Array     Int32Array
**** Uint8Array   8位无符号整型数    Uint16Array    UInt32Array
**** Float32Array   Float64Array
*** mat4  4*4矩阵
*** gl.uniformMaterix4fv
**** location 
**** transpose   一般为false
**** array      类型化数组,4*4矩阵按列主序
* 着色器
*** 顶点着色器: 控制点的位置和大小
**** vec4 gl_Position  定点位置
***** 必须被赋值, 不然片元着色器无法工作
**** float gl_PointSize 点的尺寸
***** 不是必须的,不赋值取默认值1.0
*** 片元着色器: 控制点的颜色
**** vec4 gl_FragColor  指定片元的颜色
***** 唯一内置变量, 控制着像素在屏幕上的最终颜色
* attribute 存储限定符
*** 从外部向顶点着色器内传输数据, 只有顶点着色器能使用
*** 在顶点着色器中声名attribute变量
**** attribute vec4 a_Position;
*** 通过gl.getAttribLocation 获取变量
**** 参数
***** program  指定包含定点着色器和片元着色器的程序对象
***** name     指定想要获取的attribute变量名
*** 向attribute变量传输数据
**** 通过gl.vertexAttrib1f/gl.vertexAttrib2f/gl.vertexAttrib3f/gl.vertexAttrib4f同族函数向attribute赋值
**** 当我只赋值前3个参数时,第四个参数默认为1.0
**** var position = new Float32Array([1.0,2.0,3.0]);
**** gl.vertexAttrib3fv(a_Position, position);
* uniform 存储限定符
*** 从程序向顶点着色器和片元着色器传输不变数据
*** 声名uniform变量
**** uniform vec4 a_FragColor;
*** 通过gl.getUniformLocation获取变量
**** 参数
***** programBox  指定包含定点着色器和片元着色器的程序对象
***** name     指定想要获取的uniform变量名
*** 向uniform变量传输数据
**** gl.uniform1f/gl.uniform2f/gl.uniform3f/gl.uniform4f同族函数
**** 当我只赋值前3个参数时,第四个参数默认为1.0
* varying变量
*** 从顶点着色器向片元着色器传输数据
**** 我们设置每个顶点的color, 但vb{o只能是顶点着色器使用
**** 我们可以通过varying来从顶点着色器取出值来传给片元着色器,这样我们就可以传输大量顶点color值

* 顶点缓冲对象(VBO)
*** 三角形,立方体需要一次性将顶点全部传入顶点着色器,然后才能把图形画出来.
*** 而且可以创建多个buffer来缓存多个geometry的顶点数据,当我们需要绘制时只需要取出buffer就可以绘制会图形
*** 定义:是Webgl系统中的一块内存区域, 可以一次性向缓冲区对象中填充大量顶点数据, 然后将这些数据保存在其中,供定点着色器使用
*** 步骤:
**** 创建缓冲区对象(gl.createBuffer)
**** 绑定缓冲区(gl.bindBuffer)
***** 参数:
***** target
****** gl.ARRAY_BUFFER           表示缓冲区对象中包含了顶点的数据
****** gl.ELEMENT_ARRAY_BUFFER   表示缓冲区对象中包含了顶点的索引值
***** buffer
**** 向缓冲区对象中写入数据(gl.bufferData)
***** 参数:
***** target: 
****** gl.ARRAY_BUFFER           表示缓冲区对象中包含了顶点的数据
****** gl.ELEMENT_ARRAY_BUFFER   表示缓冲区对象中包含了顶点的索引值
***** buffer
***** usage         程序如何使用存储在缓冲区对象中的数据
****** gl.STATIC_DRAW     只会向缓冲区对象中写入一次数据,需要绘制多次
****** gl.STREAM_DRAW     只会向缓冲区对象中写入一次数据,绘制若干次
****** gl.DYNAMIC_DRAW    向缓冲区对象写入多次数据,绘制多次
**** 将缓冲区对象分配给attribute变量(gl.vertexAttribPointer)
***** location      指定attribute变量存储位置
***** size          缓冲区每个顶点的分量个数(1-4)
***** type
****** gl.UNSIGNED_BYTE   无符号字节,UInt8Array
****** gl.SHORT           短整型,Int16Array
****** gl.UNSIGNED_SHORT  无符号短整型,UInt16Array
****** gl.INT             整型,Int32Array
****** gl.UNSIGNED_INT    无符号整型,UInt32Array
****** gl.FLOAT           浮点数,Float32Array
***** normalize    一般为false
***** stride       指定相邻2个顶点间的字节数,默认为0
***** offset       缓存区对象中的偏移量
**** 开启attribute变量(gl.enableVertexAttribArray)
* 绘制管线:给定视点,三维物体,光源,照明模式,纹理等元素,绘制一副二维图像
** 渲染流程：由用户通过VBO将大量顶点数据传给GPU，在GPU中执行顶点着色器开始，完成
** 渲染管线:
*** 顶点着色器:
**** 执行顶点着色器,缓冲区对象第一个坐标(0.0,0.5)被传递给attribute变量a_position
**** 一旦一个顶点坐标被赋值给gl_Position,他就进入图形装配区域,暂时存储在那
**** 再次执行顶点着色器,将剩余的顶点依次存储到图形装配区,进行装配图形
*** 图元装配
**** 将顶点着色器输出的所有顶点作为输入,将所有点装配成指定的图元的形状(三角形,点)
**** 这里把所有顶点都绘制出来，没有进行裁剪操作
**** 然后把装配的图形传给几何着色器
*** 几何阶段
**** 需要对超出屏幕外的三角形进行裁剪
**** 想象一下，一个三角形其中一个顶点在画面外，这时我们看到的是一个四边形，这时需要把四边形切成两个小的三角形
**** 将一系列顶点集合作为输入,通过产生新的顶点构造出新的图元来生成其他形状(三角形)
**** 这个阶段还有背面剔除操作，减少绘制的顶点个数
**** 这个阶段得到一堆在屏幕坐标上的三角片面，用于光栅化
*** 光栅化阶段
**** 把图元映射为最终屏幕上相应的像素,生成供片元着色器使用的片段
**** 在片元着色器执行前会执行裁剪,裁剪丢弃你超出你试图以外的像素
**** 包括：
***** 遮挡面剔除：深度测试的过程
***** 纹理操作：根据像素纹理坐标，获取对应纹理值
***** 混色：根据目前已经画好的颜色，与正在计算的颜色的透明度，混合为两种颜色，作为新的颜色输出
***** 滤镜：将正在计算的颜色通过滤镜后输出
*** 片元着色器
**** 计算像素最终颜色
**** 通过该阶段后，像素的颜色值被写入帧缓存中
** 应用阶段:
*** 碰撞检测,场景图建立,空间八叉树更新,视锥裁剪都在此阶段
*** 该阶段末尾,几何数据(顶点坐标,法向量,纹理坐标,纹理等)通过数据总线传送到GPU
**** 这里由用户把顶点数据通过顶点缓冲对象传入到GPU,然后通过GPU渲染管线
** 几何阶段:
*** 主要负责顶点坐标变换,光照,裁剪,投影以及屏幕映射,该阶段基于GPU进行运算
*** 该阶段末尾得到了经过变换和投影之后的顶点坐标,颜色,以及纹理坐标
*** 这个阶段执行了坐标系转换
** 光栅化阶段
*** 基于几何阶段的输出数据,为像素正确配色,该阶段都是操作单个像素,每个像素的信息存储在颜色缓冲器中
** PS:
*** 光照计算属于几何阶段
**** 因为光照涉及到视点,光源和物体的世界坐标,通常在世界坐标系中进行计算
*** 雾化和涉及物体透明度计算属于光栅化阶段
**** 因为用到了深度信息z值,而z值是在几何阶段中计算,并传入到光栅阶段的,只能在光栅阶段获取到
*** 屏幕是二维的,GPU所需要做的就是将三维的数据绘制到二维屏幕上,顶点变换每个过程都是这个目的
* 坐标系统
** 局部空间
*** 模型文件中的顶点值,是在建模型时得到的
*** 与其他物体是没有任何参照关系的
*** PS:顶点法向量在模型中属于局部坐标,在GPU顶点着色器程序中必须将法向量转换到世界坐标系才能使用
** 世界坐标系
*** 指顶点相对于游戏世界的坐标.
*** 物体坐标从局部坐标转换到世界坐标,该转换由模型矩阵实现
*** Model Matrix: 通过对物体进行位移,缩放,旋转来将它置于他本应该在的位置和朝向
** 观察空间
*** 将世界坐标转化为用户视野前方的坐标而产生的结果
*** 就是摄像机的视角所观察到的空间
*** 观察矩阵(View Matrix)，它被用来将世界坐标变换到观察空间。
** 裁剪空间
*** 一旦顶点坐标被转换到观察空间,就需要判断哪些视点是可见的,会将投影矩阵以外的点去除,称为视锥裁剪
*** 裁剪被安排到一个单位立方体中进行,该立方体顶点分别是(-1,-1,-1)和(1,1,1),被称为规范立方体(CVV)
*** CVV的近平面(梯形较小的矩形面)的X,Y坐标对应屏幕像素坐标,z代表画面深度
*** 从视点坐标到裁剪坐标经过以下3步:
*** 1.用透视矩阵把顶点从视锥中变换到CVV中(投影)
*** 2.在CVV中进行图片裁剪
*** 3.屏幕映射
* 程序对象(program)
* GPU VS CPU
** GPU
*** 具有高并行结构，所以GPU在处理图形数据和复杂算法方面拥有比CPU更高的效率
*** GPU拥有大面积ALU（逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，这样结构适合并行处理密集型数据
*** 具有多个处理器核，在一个时刻可以进行多个数据处理
*** 采用流式并行计算模式，对每个数据进行独立的并行计算，即流内任意元素的计算不依赖于其他同类型数据
*** 并行计算：多个数据同时被使用，多个数据并行计算的时间和1个数据单独执行的时间是一样的
** CPU
*** CPU大面具为控制器和寄存器
*** CPU执行计算任务时，一个时刻只能处理一个数据，而不存在并行处理
